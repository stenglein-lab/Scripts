#!/usr/bin/perl

# this script parses a SAM output file
# and outputs the fraction of bases that 
# are "soft trimmed" at each position in the 
# reference sequence
#
# Mark Stenglein November 17, 2015
#

use strict;
use Getopt::Long;

my $usage = <<USAGE;

This script parses a SAM output file and outputs the fraction of bases that are "soft trimmed" at each 
position in the reference sequence

Assumes a sam file generated by alignment to a single reference sequence using an alignment tool
like bowtie2 run in local mode that performs "soft trimming"

Outputs to stdout

Mark Stenglein November 17, 2015

 usage: $0  [h] <sam_file>

   -h                print this message

USAGE

my $print_usage = 0;
my $output_unmapped = 0;

if (scalar @ARGV == 0 and -t STDIN) { print $usage; exit; }

GetOptions ("h" => \$print_usage); 

if ($print_usage) { print $usage; exit; }

my $flag = 0;
my @fields = ();
my @tags = ();
my $seq_name = undef;
my $seq_length = undef;
my %histo = ();

while (<>)
{
   chomp;

   if (/^@/)
   {
      # @SQ   SN:Umbrella_L_cladeF_v1 LN:6927
      if (/\@SQ\s+SN:(\S+)\s+LN:(\d+)/)
      {
         if (defined $seq_name)
         {
            die "error - this script only supports SAM files with a single ref seq.\n";  # TODO - extend
         }
         $seq_name = $1;
         $seq_length = $2;
      }
      # don't do anything else w/ header lines
      next;
   }
   
   # split line into tab-delimited components
   @fields = split "\t";

   # is this an unmapped query?
   my $flag = $fields[1];
   # don't output unmapped queries
   # see SAM format spec.
   if ($flag & 4) { next; }
   
   my $start_pos = $fields[3];
   my $cigar = $fields[5];

   # leftmost aligned base 
   my $position_in_reference = $start_pos;

   # cigar parsing code copied from: http://davetang.org/muse/2011/01/28/perl-and-sam/
   while ($cigar !~ /^$/)
   {
      if ($cigar =~ /^([0-9]+[MIDS])/)
      {
         my $cigar_part = $1;
         # if a match
         if ($cigar_part =~ /(\d+)M/)
         {
            my $number_matches = $1;
            # For each matched base, increment tally for that position in reference by 1
            for (my $i = 0; $i < $number_matches; $i++)
            {
               $histo{$position_in_reference}{total_bases} += 1;
               $position_in_reference += 1;
            }
         } 
         # if an insertion (in read), do nothing
         elsif ($cigar_part =~ /(\d+)I/)
         {
            # TODO: something else here?
            # nada 
         } 
         # if a deletion (in read), simply jump ahead in ref
         elsif ($cigar_part =~ /(\d+)D/)
         {
            # TODO: something else here?
            $position_in_reference += $1;
         } 
         elsif ($cigar_part =~ /(\d+)S/)
         {
            # soft clipping occurs only at ends of sequence
            # and the reported start position (field[3]), is 
            # the leftmost *aligned* base
            my $number_trimmed = $1;
            # For each trimmed base
            for (my $i = 0; $i < $number_trimmed; $i++)
            {
               # increment tallies for total bases as well as trimmed bases
               $histo{$position_in_reference}{total_bases} += 1;
               $histo{$position_in_reference}{trimmed_bases} += 1;
               $position_in_reference += 1;
            }
         } 
         $cigar =~ s/$cigar_part//;
      } 
      else 
      {
         die "Unexpected cigar: $cigar\n";
      }
   }
}

foreach (my $i = 1; $i <= $seq_length; $i++)
{
   my $total_bases = $histo{$i}{total_bases};
   my $trimmed_bases = $histo{$i}{trimmed_bases};
   my $fraction_trimmed = 0;
   if ($total_bases > 0)
   {
     $fraction_trimmed = sprintf ("%0.2f", ($trimmed_bases / $total_bases));
   }
   print "$i\t$total_bases\t$trimmed_bases\t$fraction_trimmed\n";
}
